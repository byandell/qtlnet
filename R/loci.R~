loci.qtlnet <- function(qtlnet.object, chr.pos=TRUE, merge.qtl = 10,
                        ...)
{
  cross <- qtlnet.object$cross
  ## Make sure cross object has genotype probabilities.
  if (!("prob" %in% names(cross$geno[[1]]))) {
      warning("First running calc.genoprob.")
    cross <- calc.genoprob(cross)
  }

  pheno.net.str <- get.averaged.net(qtlnet.object)

  ## Extract needed attributes from qtlnet.object.
  pheno.nms <- attr(qtlnet.object, "pheno.names")
  addcov <- attr(qtlnet.object, "addcov") 
  intcov <- attr(qtlnet.object, "intcov") 
  thr <- attr(qtlnet.object, "threshold")
  method <- attr(qtlnet.object, "method")

  n.pheno <- length(pheno.nms)
  ss <- list()
  for(i in seq(n.pheno)){
    pa <- get.parents(pheno=pheno.nms[i], pheno.net.str=pheno.net.str)

    ## Reduce to nonmissing data.
    tmp <- unique(c(i, pa, addcov[[i]], intcov[[i]]))
    pheno.na <- apply(cross$pheno[, tmp, drop = FALSE], 1,
                      function(x) any(is.na(x)))
    crossi <- subset(cross, ind = !pheno.na)

    ## Determine parent covariates.
    pacov.dat <- NULL
    if(!is.null(pa))
      pacov.dat <- as.matrix(crossi$pheno[, pa, drop = FALSE])

    ## Determine additive and interactive covariates.
    addcov.dat <-
      create.cov.matrix(crossi, cov.names = unique(c(addcov[[i]], intcov[[i]])))
    addcov.dat <- cbind(pacov.dat, addcov.dat)
    intcov.dat <- create.cov.matrix(crossi, cov.names = intcov[[i]])
    
    ss[[i]] <- scanone.summary(crossi, i, addcov.dat, intcov.dat, thr[[i]], method)
  }
  if(merge.qtl > 0) {
    ## If QTL within merge.qtl of mean pos for that chr, use mean pos.
    chr <- unlist(sapply(ss, function(x) x$chr))
    pos <- unlist(sapply(ss, function(x) x$pos))
    mpos <- tapply(pos, chr, mean)

    ## Need to re-get markers if !chr.pos.
    if(!chr.pos) {
      name.pos <- mpos
      for(j in names(mpos[!is.na(mpos)])) {
        map <- pull.loci(qtlnet.object$cross, j)
        wh <- names(which.min(abs(map - mpos[j]))[1])
        if(substring(wh, 1, 3) == "loc")
          wh <- paste("c", j, ".", wh, sep = "")
        name.pos[j] <- wh
      }
    }
    for(i in seq(n.pheno)) {
      dif <- mpos[ss[[i]]$chr] - ss[[i]]$pos
      is.close <- abs(dif) <= merge.qtl
      if(any(is.close)) {
        ss[[i]]$pos <- ss[[i]]$pos + is.close * dif
        if(!chr.pos)
          row.names(ss[[i]])[is.close] <- name.pos[ss[[i]]$chr][is.close]
      }
    }
  }
    
  QTLnodes <- list()
  for(i in seq(n.pheno)){
    markers <- row.names(ss[[i]])
    le.markers <- length(markers)
    if(le.markers > 0){ 
      if(chr.pos){
        QTLnodes[[i]] <- paste("chr", ss[[i]][,1], "@", round(ss[[i]][,2], 2), sep = "")
      }
      else{
        QTLnodes[[i]] <- markers
      }
    }
    if(le.markers == 0){
      QTLnodes[[i]] <- markers
    }   
  }
  names(QTLnodes) <- pheno.nms
  QTLnodes
}
######################################################################
get.parents <- function(pheno, pheno.net.str)
{
  aux1 <- which(pheno.net.str[,2] == pheno)
  pa <- pheno.net.str[pheno.net.str[,2] == pheno, 1]
  if(length(pa) == 0) return(NULL)
  else return(pa)
}
######################################################################
pull.loci <- function(cross, i)
{
  ## Taken directly from R/qtl scanone.
  stp <- attr(cross$geno[[i]]$prob, "step")
  oe <- attr(cross$geno[[i]]$prob, "off.end")
  if ("stepwidth" %in% names(attributes(cross$geno[[i]]$prob))) 
    stpw <- attr(cross$geno[[i]]$prob, "stepwidth")
  else stpw <- "fixed"
  map <- create.map(cross$geno[[i]]$map, stp, oe, stpw)
}
