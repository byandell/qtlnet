plot.qtlnet <- function(x, ...)
{
  require(igraph)
  
  gr <- graph.qtlnet(x, ...)
  tkplot(gr, ...)
  
  invisible(gr)
}
###################################################################
graph.qtlnet <- function(x, ...) igraph.qtlnet(x, ...)
###################################################################
## This creates object of class igraph.
igraph.qtlnet <- function(x,
                         edges = summary(x, ...)$averaged.net,
                         loci.list = loci.qtlnet(x, ...),
                         pheno.color="green", qtl.color="red",
                         vertex.color = node.color,
                         include.qtl=TRUE,
                         ...)
{
  require(igraph)
  
  node.names <- levels(edges[[1]])
  if(is.null(node.names))
    node.names <- unique(c(as.character(edges[[1]]), as.character(edges[[2]])))

  if(is.null(loci.list) | !include.qtl)
    node.color <- pheno.color
  else {
    loci.data.frame <- data.frame(qtl = unlist(loci.list))
    loci.data.frame$pheno <- rep(names(loci.list), sapply(loci.list, length))

    pheno.names <- node.names
    node.names <- c(pheno.names, levels(loci.data.frame[[1]]))

    edges <- cbind.data.frame(cause = c(as.character(edges[[1]]),
                                as.character(loci.data.frame[[1]])),
                              effect = c(as.character(edges[[2]]),
                                as.character(loci.data.frame[[2]])),
                              width = c(edges[[3]],
                                rep(1, nrow(loci.data.frame))))

    node.color <- rep(qtl.color, length(node.names))
    node.color[node.names %in% pheno.names] <- pheno.color
  }

  ## Not sure how these get set up and passed.
  ## Set up vertices
  vertex.color <- array(vertex.color, length(node.names))
  vertices <- data.frame(name = node.names, label = node.names,
                         color = vertex.color, fill = vertex.color)

  ## Great graph object (library igraph).
  igraph.par("print.graph.attributes", TRUE)
  igraph.par("print.vertex.attributes", TRUE)
  igraph.par("print.edge.attributes", TRUE)
  graph.data.frame(edges, TRUE, vertices = vertices)
}
##################################################################
## Following routines are highly dependent on how igraph objects are structured.
##################################################################
get.graph.vertices <- function(graph)
{
  attr <- list.vertex.attributes(graph)
  out <- list()
  for(i in attr)
    out[[i]] <- get.vertex.attribute(graph, i)
  data.frame(out)
}
############################################################
get.graph.edges <- function(graph)
{
  attr <- list.edge.attributes(graph)
  out <- as.data.frame(get.edgelist(graph))
  names(out) <- c("cause","effect")
  for(i in attr)
    out[[i]] <- get.edge.attribute(graph, i)
  out
}
